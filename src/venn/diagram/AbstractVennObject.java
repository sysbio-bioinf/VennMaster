/*
 * Created on 30.05.2005
 *
 */
package venn.diagram;

import java.awt.Color;
import java.util.BitSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;

import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import venn.geometry.FPoint;

/**
 * Abstract base class for graphical Venn objects.
 * See e.g. {@link venn.diagram.VennPolygonObject}.
 * Normally they will be generated by the {@link venn.diagram.VennObjectFactory}.
 * 
 * @author muellera
 *
 */
public abstract class AbstractVennObject
implements IVennObject
{
    private LinkedList      listeners;
    
    private final BitSet    elements;
    private final int       card;
    private FPoint 	        center;
    private double          scale;

    private double rotation;
    private double ratio;

    private Object          properties;
    private Color           fillColor,
                            borderColor;
    private boolean         locked;
    /**
     * 
     */
    public AbstractVennObject( BitSet elements ) 
    {
        this.properties = null;
        this.elements = elements;
        this.card = elements.cardinality();
        this.fillColor = Color.BLUE;
        this.borderColor = Color.BLACK;
        
        center = new FPoint(0.5,0.5);		// TODO ME this should not be always so, right? -> getCenter(), furthermore...randomize?
        scale = 1.0;
        
        this.ratio = 1.0;	// [ME] TODO start with 1.0? randomize?
        this.rotation = 0.0;	// [ME] randomize?
        
        listeners = new LinkedList(); 
        this.locked = false;
    }
    
    public void setLock( boolean locked )
    {
        this.locked = locked;
    }
    
    public boolean getLock()
    {
        return locked;
    }
    
    /* (non-Javadoc)
     * @see venn.IVennObject#getPosition()
     */
    public FPoint getOffset() 
    {
        return center;
    }

    /* (non-Javadoc)
     * @see venn.IVennObject#setPosition(venn.geometry.FPoint)
     */
    public void setOffset(FPoint p) 
    {
        if( p == null )
            throw new IllegalArgumentException("p must not be null");
        
        if( locked )
            return;
        
        if( ! center.equals(p) )
        {
            center = p;
            invalidate();
        }
    }
    
    public double getScale()
    {
        return scale;
    }
    
    public void setScale( double scale )
    {
        if( locked )
            return;
        
        if( scale != this.scale )
        {
            this.scale = scale;
            invalidate();
        }
    }
       
    public double getRatio()
    {
    	return ratio;
    }
    
    public void setRatio(double _ratio)
    {
    	if(locked)
    		return;
    	
    	if(this.ratio != _ratio)
    	{
    		this.ratio = _ratio;
    		invalidate();
    	}
    }

    public double getRotation()
    {
    	return rotation;
    }
    
    /*
     * [0...180] (other values will be adjusted)
     * would be easer using radians
     */
    public void setRotation(double _rotation)
    {
    	if(locked)
    		return;

    	double rot = _rotation % 180.0;
    	rot = rot < 0.0 ? (180 + rot) : rot; 
    	if(rot != this.rotation)
    	{
    		this.rotation = rot;
    		invalidate();
    	}
    }

    /* (non-Javadoc)
     * @see venn.IVennObject#cardinality()
     */
    public int cardinality() 
    {
        //return getElements().cardinality();
        return card;
    }

    /* (non-Javadoc)
     * @see venn.IVennObject#getElements()
     */
    public BitSet getElements() 
    {
        return elements;
    }
        
    public synchronized void addChangeListener( ChangeListener obj )
    {
        if( obj != null )
            listeners.add( obj );
    }
    
    public synchronized void removeChangeListener( ChangeListener obj )
    {
        if( obj != null )
            listeners.remove(obj);
    }
    
    public void fireChangeEvent()
    {
        synchronized( listeners )
        {
            Iterator iter = listeners.iterator();
            ChangeEvent event = new ChangeEvent(this);
            
            while( iter.hasNext() )
            {
                ((ChangeListener)iter.next()).stateChanged( event );
            }
        }
    }
    
    public void setProperties( Object properties )
    {
        this.properties = properties;
    }
    
    public Object getProperties()
    {
        return this.properties;
    }
    
    public void setFillColor( Color color )
    {
        fillColor = color;
    }
    
    public Color getFillColor()
    {
        return fillColor;
    }
    
    public void setBorderColor( Color color )
    {
        borderColor = color;
    }
    
    public Color getBorderColor()
    {
        return borderColor;
    }
    
    public String toString()
    {
        StringBuffer buf = new StringBuffer();
        
        buf.append("ELEMENTS ");
        buf.append( elements.toString() );
        buf.append("\n");
        
        buf.append("CARD ");
        buf.append(cardinality());
        buf.append("\n");
        
        buf.append("AREA ");
        buf.append(area());
        buf.append("\n");
        
        buf.append("CENTER ");
        buf.append( center.toString() );
        buf.append("\n");
        
        buf.append("SCALE ");
        buf.append( scale + ", ");

        buf.append("ROTATION: " + Double.toString(getRotation()) + ", ");
        buf.append("RATIO: " + Double.toString(getRatio()) + "\n");
        return buf.toString();
    }

    /**
     * Assigns all positions and scales of the source object to this object.
     */
    public void assignState( IVennObject source )
    {
        if( source == null )
            throw new IllegalArgumentException("source must not be null!");
        
        setLock(false);
        setOffset(source.getOffset());
        setScale(source.getScale());
        setRatio(source.getRatio());
        setRotation(source.getRotation());
        setLock(source.getLock());
    }
}
